package opa

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/hcl/v2"
	"github.com/open-policy-agent/opa/ast"
	"github.com/open-policy-agent/opa/loader"
	"github.com/open-policy-agent/opa/rego"
	"github.com/open-policy-agent/opa/storage"
	"github.com/terraform-linters/tflint-plugin-sdk/tflint"
)

// Engine evaluates policies and returns the results.
// In other words, this is a wrapper of rego.New(...).Eval().
type Engine struct {
	store   storage.Store
	modules map[string]*ast.Module
}

// NewEngine returns a new engine based on the policies loaded
func NewEngine(ret *loader.Result) (*Engine, error) {
	store, err := ret.Store()
	if err != nil {
		return nil, err
	}

	return &Engine{
		store:   store,
		modules: ret.ParsedModules(),
	}, nil
}

// Result is the result of the query.
// It corresponds to an element of the Set document generated by the rule
// in Rego, and is a concept corresponding to tflint.Issue.
type Result struct {
	message  string
	severity tflint.Severity
	location hcl.Range
}

// RunQuery executes a query referencing a rule and returns the generated
// Set document as Result.
// rego.ResultSet is parsed according to the following conventions:
//
// - All rules should be under the "tflint" package
// - Rule should return a Set document
// - The elements of the set must be objects consisting of "message" and "severity", and "location".
//
// Example:
//
// ```
//
//	deny_test[issue] {
//	  [condition]
//
//	  issue := {
//	    "message": "test",
//	    "severity": "error",
//	    "location": resource.decl_range
//	  }
//	}
//
// ```
func (e *Engine) RunQuery(rule *Rule, runner tflint.Runner) ([]*Result, error) {
	regoOpts := []func(*rego.Rego){
		// All rules should be under the "tflint" package
		rego.Query(fmt.Sprintf("data.tflint.%s", rule.RegoName())),
		rego.Store(e.store),
	}

	for _, m := range e.modules {
		regoOpts = append(regoOpts, rego.ParsedModule(m))
	}

	regoOpts = append(regoOpts, Functions(runner)...)

	rs, err := rego.New(regoOpts...).Eval(context.Background())
	if err != nil {
		return nil, err
	}

	var results []*Result
	for _, result := range rs {
		for _, expr := range result.Expressions {
			values, ok := expr.Value.([]any)
			if !ok {
				return nil, fmt.Errorf("rule document content is not set, got %T", expr.Value)
			}

			for _, value := range values {
				ret, err := jsonToResult(value, "issue")
				if err != nil {
					return nil, err
				}
				results = append(results, ret)
			}
		}
	}

	return results, err
}

func jsonToResult(in any, path string) (*Result, error) {
	ret, err := jsonToObject(in, path)
	if err != nil {
		return nil, err
	}

	message, err := jsonToString(ret["message"], fmt.Sprintf("%s.message", path))
	if err != nil {
		return nil, err
	}
	severity, err := jsonToSeverity(ret["severity"], fmt.Sprintf("%s.severity", path))
	if err != nil {
		return nil, err
	}
	location, err := jsonToRange(ret["location"], fmt.Sprintf("%s.location", path))
	if err != nil {
		return nil, err
	}

	return &Result{message: message, severity: severity, location: location}, nil
}

func jsonToSeverity(in any, path string) (tflint.Severity, error) {
	severity, err := jsonToString(in, path)
	if err != nil {
		return tflint.ERROR, err
	}

	switch strings.ToLower(severity) {
	case "error":
		return tflint.ERROR, nil
	case "warning":
		return tflint.WARNING, nil
	case "notice":
		return tflint.NOTICE, nil
	default:
		return tflint.ERROR, fmt.Errorf("%s is invalid: %s", path, in)
	}
}
