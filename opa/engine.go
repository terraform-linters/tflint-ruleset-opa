package opa

import (
	"context"
	"fmt"
	"strings"

	"github.com/open-policy-agent/opa/ast"
	"github.com/open-policy-agent/opa/loader"
	"github.com/open-policy-agent/opa/rego"
	"github.com/open-policy-agent/opa/storage"
	"github.com/terraform-linters/tflint-plugin-sdk/tflint"
)

// Engine evaluates policies, generates a list of tflint.Rule,
// and returns the results.
// In other words, this is a wrapper of rego.New(...).Eval().
type Engine struct {
	store   storage.Store
	modules map[string]*ast.Module

	rules []tflint.Rule
}

func EmptyEmgine() *Engine {
	return &Engine{}
}

// NewEngine returns a new engine based on the policies loaded
func NewEngine(ret *loader.Result) (*Engine, error) {
	store, err := ret.Store()
	if err != nil {
		return nil, err
	}

	var rules []tflint.Rule
	for _, module := range ret.ParsedModules() {
		for _, rule := range module.Rules {
			if r := NewRule(rule.Head.Name.String()); r != nil {
				rules = append(rules, r)
			}
		}
	}

	return &Engine{
		store:   store,
		modules: ret.ParsedModules(),
		rules:   rules,
	}, nil
}

// Result is the result of the query.
// It corresponds to an element of the Set document generated by the rule
// in Rego, and is a concept corresponding to tflint.Issue.
type Result struct {
	message  string
	severity tflint.Severity
}

// RunQuery executes a query referencing a rule and returns the generated
// Set document as Result.
// rego.ResultSet is parsed according to the following conventions:
//
// - All rules should be under the "tflint" package
// - Rule should return a Set document
// - The elements of the set must be objects consisting of "message" and "severity".
//
// Example:
//
// ```
//
//	deny_test[issue] {
//	  [decision]
//
//	  issue := {
//	    "message": "test",
//	    "severity": "error"
//	  }
//	}
//
// ```
func (e *Engine) RunQuery(rule *Rule) ([]*Result, error) {
	regoOpts := []func(*rego.Rego){
		// All rules should be under the "tflint" package
		rego.Query(fmt.Sprintf("data.tflint.%s", rule.RegoName())),
		rego.Store(e.store),
	}

	for _, m := range e.modules {
		regoOpts = append(regoOpts, rego.ParsedModule(m))
	}

	rs, err := rego.New(regoOpts...).Eval(context.Background())
	if err != nil {
		return nil, err
	}

	var results []*Result
	for _, result := range rs {
		for _, expr := range result.Expressions {
			values, ok := expr.Value.([]any)
			if !ok {
				return nil, fmt.Errorf("rule document content is not set, got %T", expr.Value)
			}

			for _, value := range values {
				issue, ok := value.(map[string]any)
				if !ok {
					return nil, fmt.Errorf("issue is not object, got %T", value)
				}

				message, ok := issue["message"].(string)
				if !ok {
					return nil, fmt.Errorf("message is not string, got %T", issue["message"])
				}

				severityStr, ok := issue["severity"].(string)
				if !ok {
					return nil, fmt.Errorf("severity is not string, got %T", issue["severity"])
				}
				severity, err := asSeverity(severityStr)
				if err != nil {
					return nil, err
				}

				results = append(results, &Result{message: message, severity: severity})
			}
		}
	}

	return results, err
}

func asSeverity(in string) (tflint.Severity, error) {
	switch strings.ToLower(in) {
	case "error":
		return tflint.ERROR, nil
	case "warning":
		return tflint.WARNING, nil
	case "notice":
		return tflint.NOTICE, nil
	default:
		return tflint.ERROR, fmt.Errorf("invalid severity: %s", in)
	}
}
